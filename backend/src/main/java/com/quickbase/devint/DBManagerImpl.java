package com.quickbase.devint;

import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;

/* SCHEMA
 * 
 * CREATE TABLE City (
 *   CityId int NOT NULL,
 *   CityName varchar(2000) NOT NULL,
 *   StateId int NOT NULL,
 *   Population int,
 *   Primary key (CityId),
 *   Foreign key (StateId) references State(StateId))
 * 
 * CREATE TABLE State (
 *   StateId int NOT NULL,
 *   StateName varchar(2000) NOT NULL,
 *   CountryId int NOT NULL,
 *   Primary key (StateId),
 *   Foreign key (CountryId) references Country(CountryId))
 *   
 * CREATE TABLE Country (CountryName varchar(2000), CountryId int)
 * 
 * 
 * (generated by querying sqlite_master table for its sql column)
 * 
 * There are Several duplicates in this table. A quick check of the census for, e.g. Zwingle, IA, USA, suggests that the sum of the entries is correct
 * (pop. 91 is very close to the 2016 figure of 89, whereas either of the 65 or 26 records seem far too low to be a complete figure). So we'll sum them up
 * as we aggregate them. It'd be a lot harder if it was the opposite, as we'd need to hold a lot of extra state to screen them out.
 */



/**
 * This DBManager implementation provides a connection to the database containing population data.
 *
 * Created by ckeswani on 9/16/15.
 */
public class DBManagerImpl implements DBManager {
    public Connection getConnection() {
        Connection c = null;
        try {
            Class.forName("org.sqlite.JDBC");
            c = DriverManager.getConnection("jdbc:sqlite:resources/data/citystatecountry.db");
        } catch (ClassNotFoundException cnf) {
            System.out.println("could not load driver");
        } catch (SQLException sqle) {
            System.out.println("sql exception:" + Arrays.toString(sqle.getStackTrace()));
        }
        return c;
    }
    
	public List<Pair<String, Integer>> getPopulationData() throws SQLException {
		HashMap<String, Integer> pop = new HashMap<>();
		
		Connection c = getConnection();
		if (c!=null) {
			PreparedStatement stmt = c.prepareStatement("SELECT * FROM City, State, Country WHERE City.StateId = State.StateId AND State.CountryId = Country.CountryId");
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				String key = rs.getString("CountryName");
				
				Integer value = pop.get(rs.getString("CountryName"));
				if (value==null) value = 0;
				value = value + rs.getInt("Population");
				pop.put(key, value);
			}
		}
		
		/*TODO: We're shuffling here from a map into a list, and then right back into a map at the other end. Most legacy code here uses List<Pair>, but
		*       we should consider continuing to move towards Map, which better models expected invariants like key uniqueness.
		*/
		return pop.entrySet()
				.stream()
				.map((entry)->Pair.of(entry.getKey(), entry.getValue()))
				.collect(Collectors.toList());
	}
}
